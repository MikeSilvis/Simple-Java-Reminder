Mike Silvis
Brian Wenner

IST 412 Design/Test Notebook


Thursday 10/06/2011 - Deliverable 1

We began the initial design and coding of our test system today. We plan on making a reminder/postit note application that utilizes a login and password in order to save a given user's reminders and notes to themselves. In addition, we aim to include functionality supporting the sending of notes from one registered user to another. This allows users of the system to share reminders that may apply to more than one person. Other functionality of the system includes the ability to delete saved reminders that no longer apply, as well as the ability to register for new accounts. We have also started a Visio XML diagram to help us in our future efforts at creating this system, but this a VERY preliminary draft.

Our work so far has largely revolved around the development of the login and registration functions, as well as their associated graphical user interfaces. This requires the proper generation and handling of password hashes used by the system to maintain a list of current users. The classes associated with these function currently permit already registered to users to login and displays a placeholder message on the registration page. Certain blackbox testing practices have already been utilized to verify that the existing functions work as desired. This was achieved by carrying out commands and functions commonly expected by a standard user with no inside knowledge of our system.


Thursday 10/13/2011 - Deliverable 2

Our system is progressing nicely, both in development and testing. We have solidified our design plans, and are moving forward with the reminder application. Functionalities include login support for multiple users, the creation and deletion of saved reminders, viewing saved reminders, and sending reminders to friends who may also find them useful or interesting. The login capabilities support multiple users and the creation of new accounts. A user list is maintained, with usernames and encrypted passwords. AES encryption was implemented in order to provide a reliable, cryptographically secure means of securing passwords. This code makes use of available java cryptographic API's in order to allow for the encryption and decryption of these passwords. No decryption method is provided, in order to maintain the integrity of passwords. A one-way AES function is used to encrypt entered passwords which are then compared against stored encrypted passwords in order to permit or deny user access to our application. These passwords are encrypted using a secret key provided by us, the developers, in order to ensure that consistent cipher text values are obtained as a result of the encryption. This is achieved by generating a SHA-1 hash of the supplied plain-text key, which is then trimmed to 128 bits, the required length of the secret key used in AES encryption. We have not yet gotten to the point of validating password length and other requirements, but these additions are easy enough and will be included in our next progress update.

In terms of functional classes, our login page is nearly completely working. From this window, the user has access to the registration page, which is currently closed and not accepting the creation of new accounts. A slight issue is encountered when going back to the login page from this registration page, as the username and password fields are not displayed. This seems to be an issue with the use of pointers, and will be addressed in coming builds. Once logged in with a valid username and password combination, the user is currently greeted with a window displaying their current reminders, which, as of now, should be empty. An "add reminder" button exists, which presents a simple interface used to create new reminders. This currently exhibits an incomplete degree of functionality, and will certaintly be expanded on in the future. 

A number of software engineering tests have been selected in order to validate the design and stability of our system. Specifically, two tests from each testing paradigm, black box and white box, were selected to meet this goal. For our whitebox tests, we decided to conduct unit testing, as well as integration testing. In the first instance, small pieces of our system are validated at a very low level to ensure that they behave as desired. In the next batch of whitebox testing, integration tests will be performed. Here, our validated sections of code are combined to ensure that they function successfully, collectively and at a higher level than tested previously during unit testing. This is one step closer to a full test of our system, as it adds some of the required relationships and dependencies of the system. To satisfy our blackbox testing requirements, in which no inside knowledge of the system is required, we have elected to carry out both regression and beta tests. Regression tests verify that code updates have not adversely affected the working code base and caused undesireable exceptions or errors. Beta testing ensure that the system performs at a high level as desired. At this juncture, such beta testing aims only to validate completed segments of code. These tests will be carried out continuously as our development progresses. At this point, one of each type of white and blackbox tests has been implemented. For our utilized whitebox unit testing, we made use of the jUnit framework in order to specify a class and specific fields to test. In this test, our knowledge of the specific information that the specified class requires, in this case the login page requesting a username and password, allows us to test submissions with both valid and invalid data. The first test case provides an incorrect username and password, the second provides a correct username with incorrect password, and the final test case supplies both a valid username and password. The blackbox paradigm of regression testing was employed throughout the development of our existing code. As classes were updated, we continually went back and verified that these updates maintained functionality while reducing the scope of any negative consequences. Further envisioned tests include a small program in order to validate passwords against established length and content requirements.

Thursday 10/27 - Deliverable 3 + start of final report

The functionality of our system is progressing considerably. Old issues regarding pointers and navigating from the signup page back to the login page have been fixed. In the past, a duplicate, empty window was opened once the button to return had been pressed. This was due to an issue with GUI pointers within the program that his since been modified, permitting seemless navigation through the two windows without the hassle of closing a useless, superfluous window. This improves the registration and login procedure for our application. Our initial attempt at securing and storing valid password hashes for the purpose of a user list is still being employed. To remind the reader of this journal, this makes use of a one-way, 128 bit AES encryption procedure that utilizes a trimmed SHA-1 hash of our plain-text cipher key. Further improvements to the login and password storage system will come in the form of password validation, including length requirements (10-20 characters), alphabet requirements (lower and upper-case English alphanumeric characters, as well as the ten special SHIFT characters found on a standard keyboard), and finally content requirements (one uppercase, one lowercase, and one special character). Enforcing these requirements ensures that our users rely on strong, cryptographically secure passwords with length and content sufficient enough to prevent successful simple password attacks on our reminder system.

Regarding the functional aspects of our system, the capabilities to add and delete reminders have been fully realized and added to our reminder application. These two user-centric capabilities represent the core functionality of our system as it was envisioned at its outset. This is the bulk of the conceptualized reminder application. These two actions are performed via buttons within the reminder application that are displayed to the user once they have successfully logged in. Reminders are stored in a growable array list that is then accessed each time a user logs in or decides to add/remove a reminder. Utilizing an array list solves the problem of managing a persistent data storage structure without the hassle of keeping track of the size of this list and having to grow or shrink it for a desired purpose. A final improvement of our reminder application system will come in the form of the ability to share reminders, a feature that takes its inspiration from the proliferation of social networks designed around the sharing of information between online friends and aquaintances. Our application aims to provide users with the ability to specify an additional registered user with whom to share a specified reminder. The management of this function is complex enough to require additional time for completion before our final deliverable, while still wholly manageable and approachable enough to complete during the remainder of this assignment.

As mentioned in the last update of this design and test notebook, our pair has decided to employ black and whitebox testing paradigms in order to validate the construction, stability, and functionality of our system. For our whitebox tests, we are relying on the jUnit framework to target specific classes of our system for validation. This meets the whitebox testing strategy of unit testing, which is from where jUnit takes its name. In these tests, we focus on specific classes of our system in order to validate their core functionality to ensure that low level capabilities are carried out with a high degree of success. jUnit allows us to supply test cases and data that are specifically crafted to test our system in the desired areas. Once these smaller building blocks of the system have been checked and validated, testing of the lnkages between multiple classes can begin. This is best encompassed by the idea of integration testing. Here, the dependencies between classes are stressed to ensure that the system behaves desirably as a whole and to a larger, more cohesive degree than was targeted in earlier tests. Some of these integration tests have already been undertaken in order to ensure that any hiccups experiences by a given class do not necessarily carry over and adversely affect the functioning of the system as a whole. Both of these types of tests rely on our inside knowledge of the design of our system. Blackbox testing, on the other hand, does not share this requirement. These tests treat the system as an enigmatic black box, the inside functioning ofd which is unknown to the tester. For these tests, our parnetship has elected to carry out both regression and beta tests. Regression tests verify that code updates have not adversely affected the working code base and caused undesireable exceptions or errors. Beta testing ensure that the system performs at a high level as desired. At this juncture, such beta testing aims only to validate completed segments of code. These tests will be carried out continuously as our development progresses. A variety of these white and blackbox tests have been run to date in order to ensure the continued functionality of our system. jUnit tests have been developed to test our login page and usename/password combination requirements. These tests have not yet been integrated into ANT, and as a result, no testing target is found in the XML file. These tests have been run on demand and without this XML file. In addition, integration and regression tests have been utilized to continually test our updates to the overall codebase and ensure that new additions have not affected old stability. Finally, beta testing has been conducted in the form of a theoretical user navigating through all system windows in order to first create an account before beginning the process of creating and deleting reminders.